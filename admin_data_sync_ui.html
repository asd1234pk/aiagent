<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è³‡æ–™åŒæ­¥ç®¡ç† - çŸ¥è­˜åº«ç®¡ç†</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <header>
        <div class="logo">
            <!-- <img src="images/logo_placeholder.png" alt="é†«é™¢ Logo"> -->
            <h1>çŸ¥è­˜åº«ç®¡ç† - è³‡æ–™åŒæ­¥</h1>
        </div>
        <nav>
            <a href="admin_dashboard.html">è¿”å›ç®¡ç†ä¸»æ§å°</a>
            <a href="index.html">è¿”å›å…¥å£</a>
        </nav>
    </header>

    <div class="container">
        <div class="main-content">
            <h2>è³‡æ–™åŒæ­¥èˆ‡çŸ¥è­˜åº«ç®¡ç†</h2>

            <div class="sync-section">
                <h3>çŸ¥è­˜åº«æ•´é«”ç®¡ç†</h3>
                <p>æ‚¨å¯ä»¥æ‰‹å‹•è§¸ç™¼çŸ¥è­˜åº«çš„å®Œæ•´é‡å»ºã€‚æ­¤éç¨‹å¯èƒ½æœƒéœ€è¦æ•¸åˆ†é˜ï¼Œè«‹è€å¿ƒç­‰å€™ã€‚</p>
                <button id="rebuild-kb-button" class="button">ç«‹å³é‡å»ºçŸ¥è­˜åº«</button>
                <div id="rebuild-status" class="status-message" style="margin-top: 15px;"></div>
                <div id="kb-summary-status" class="status-summary-card" style="margin-top: 20px; padding: 15px; border: 1px solid #eee; border-radius: 5px; background-color: #f9f9f9;">
                    <h4>çŸ¥è­˜åº«ç‹€æ…‹æ‘˜è¦</h4>
                    <p>æ­£åœ¨è¼‰å…¥ç‹€æ…‹...</p>
                </div>
            </div>

            <hr style="margin: 30px 0;">

            <div class="sync-section">
                <h3>è³‡æ–™ä¾†æºåŒæ­¥ç®¡ç†</h3>
                <p>ç®¡ç†ä¸¦è¿½è¹¤ä¾†è‡ªä¸åŒè³‡æ–™ä¾†æºçš„çŸ¥è­˜åŒæ­¥ç‹€æ…‹ã€‚</p>

                <div class="card">
                    <div class="card-header">æœ¬åœ° Word æ–‡ä»¶</div>
                    <p>ä¾†æºè·¯å¾‘ï¼š<span id="localWordPath">/data/knowledge_docs/</span> (ç¯„ä¾‹)</p>
                    <p>ä¸Šæ¬¡åŒæ­¥æ™‚é–“ï¼š<span id="localWordLastSync">2024-07-30 09:00:15</span></p>
                    <p>ç‹€æ…‹ï¼š<span id="localWordSyncStatus" style="color: green;">åŒæ­¥æˆåŠŸ</span></p>
                    <p>å·²ç´¢å¼•æ–‡ä»¶æ•¸é‡ï¼š<span id="localWordDocCount">152</span> ä»½</p>
                    <button class="button" id="triggerLocalWordSync">ç«‹å³åŒæ­¥æœ¬åœ° Word æ–‡ä»¶</button>
                    <p style="margin-top:10px;"><small><em>æ­¤æ“ä½œå°‡æœƒæƒææŒ‡å®šç›®éŒ„ä¸­çš„ Word æ–‡ä»¶ï¼Œé€²è¡Œè™•ç†ä¸¦æ›´æ–°è‡³å‘é‡è³‡æ–™åº«ã€‚</em></small></p>
                </div>

                <!-- New Section for Word Document Management -->
                <div class="card">
                    <div class="card-header">æ‰‹å‹•ç®¡ç† Word æ–‡ä»¶</div>
                    <div class="form-group">
                        <label for="wordFileUpload">ä¸Šå‚³æ–°çš„ Word æ–‡ä»¶ (.docx)ï¼š</label>
                        <input type="file" id="wordFileUpload" accept=".docx" style="margin-bottom: 10px;">
                        <button id="uploadWordFileButton" class="button button-primary">ä¸Šå‚³æª”æ¡ˆ</button>
                    </div>
                    <div id="word-file-upload-status" class="status-message" style="margin-top:10px;"></div>
                    
                    <hr style="margin: 20px 0;"> <!-- Separator -->

                    <div class="form-group">
                        <label for="zipFileUpload">ä¸Šå‚³åŒ…å« Word æ–‡ä»¶çš„ ZIP å£“ç¸®æª” (.zip)ï¼š</label>
                        <input type="file" id="zipFileUpload" accept=".zip" style="margin-bottom: 5px;"><br>
                        <label for="extractFolderName" style="margin-right: 5px;">è§£å£“ç¸®åˆ°è³‡æ–™å¤¾ (é¸å¡«ï¼Œé è¨­ç‚º ZIP æª”å):</label>
                        <input type="text" id="extractFolderName" placeholder="ä¾‹å¦‚ï¼šå°ˆæ¡ˆAæ–‡ä»¶" style="margin-bottom: 10px; width: auto; display: inline-block;">
                        <button id="uploadZipFileButton" class="button button-success">ä¸Šå‚³ä¸¦è§£å£“ç¸® ZIP</button>
                    </div>
                    <div id="zip-file-upload-status" class="status-message" style="margin-top:10px;"></div>

                    <h4>ç›®å‰çŸ¥è­˜åº«ä¸­çš„ Word æ–‡ä»¶ï¼š</h4>
                    <div id="word-file-list-status" class="status-message"></div>
                    <div class="table-container" style="margin-top:10px;">
                        <table id="wordFilesTable">
                            <thead>
                                <tr>
                                    <th>æª”æ¡ˆåç¨±</th>
                                    <th>å¤§å°</th>
                                    <th>æœ€å¾Œä¿®æ”¹æ™‚é–“</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody id="wordFilesTableBody">
                                <!-- File list will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <!-- End New Section -->

                <div class="card">
                    <div class="card-header">é†«é™¢å®˜æ–¹ç¶²ç«™å…§å®¹</div>
                    <p>ç›®æ¨™ç¶²å€ï¼š<span id="websiteUrl">https://yourhospital.example.com/articles/</span></p>
                    <p>ä¸Šæ¬¡åŒæ­¥æ™‚é–“ï¼š<span id="websiteLastSync">2024-07-30 10:00:00</span></p>
                    <p>ç‹€æ…‹ï¼š<span id="websiteSyncStatus" style="color: darkorange;">éƒ¨åˆ†æˆåŠŸ (3ç¯‡æ–‡ç« æŠ“å–å¤±æ•—)</span></p>
                    <p>å·²ç´¢å¼•æ–‡ç« æ•¸é‡ï¼š<span id="websiteArticleCount">88</span> ç¯‡</p>
                    <button class="button" id="triggerWebsiteSync">ç«‹å³åŒæ­¥å®˜ç¶²å…§å®¹</button>
                    <p style="margin-top:10px;"><small><em>æ­¤æ“ä½œå°‡æœƒå˜—è©¦æŠ“å–å®˜ç¶²æŒ‡å®šè·¯å¾‘ä¸‹çš„æ–‡ç« å…§å®¹ï¼Œé€²è¡Œè™•ç†ä¸¦æ›´æ–°è‡³å‘é‡è³‡æ–™åº«ã€‚</em></small></p>
                </div>

                <div class="card">
                    <div class="card-header">MySQL ç—…ä¾‹è³‡æ–™åº«</div>
                    <p>ä¸Šæ¬¡åŒæ­¥æ™‚é–“ï¼š<span id="mysqlLastSync">2024-07-30 08:30:00</span></p>
                    <p>ç‹€æ…‹ï¼š<span id="mysqlSyncStatus" style="color: green;">åŒæ­¥æˆåŠŸ</span></p>
                    <p>å·²ç´¢å¼•ç—…ä¾‹ç­†æ•¸ï¼š<span id="mysqlRecordCount">5,870</span> ç­† (è¿‘ä¸€å¹´ç¬¦åˆæ¢ä»¶è€…)</p>
                    <button class="button" id="triggerMysqlSync">ç«‹å³åŒæ­¥ MySQL ç—…ä¾‹</button>
                     <p style="margin-top:10px;"><small><em>æ­¤æ“ä½œå°‡æœƒå¾ MySQL ç—…ä¾‹ç³»çµ±ä¸­æå–ç›¸é—œæ¬„ä½ï¼Œè½‰æ›æ ¼å¼ä¸¦æ›´æ–°è‡³å‘é‡è³‡æ–™åº«ã€‚</em></small></p>
                </div>
            </div>

            <h3>åŒæ­¥æ—¥èªŒ (æœ€è¿‘ 10 ç­†)</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>æ™‚é–“</th>
                            <th>è³‡æ–™ä¾†æº</th>
                            <th>ç‹€æ…‹</th>
                            <th>è©³ç´°è³‡è¨Š</th>
                        </tr>
                    </thead>
                    <tbody id="syncLogTableBody">
                        <!-- Log entries will be populated here by JavaScript -->
                    </tbody>
                </table>
            </div>

        </div>
    </div>

    <footer>
        <p class="footer-text">&copy; 2024 æ‚¨çš„é†«é™¢åç¨±. All Rights Reserved.</p>
    </footer>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Rebuild Knowledge Base Button
            const rebuildKbButton = document.getElementById('rebuild-kb-button');
            const rebuildStatusDiv = document.getElementById('rebuild-status');
            const kbSummaryStatusDiv = document.getElementById('kb-summary-status'); 
            const apiBaseUrl = '/api/admin';

            // Website Sync Elements
            const triggerWebsiteSyncButton = document.getElementById('triggerWebsiteSync');
            const websiteLastSyncSpan = document.getElementById('websiteLastSync');
            const websiteSyncStatusSpan = document.getElementById('websiteSyncStatus');
            const websiteArticleCountSpan = document.getElementById('websiteArticleCount');
            const websiteUrlSpan = document.getElementById('websiteUrl');

            // Word Documents Sync Elements (New)
            const triggerLocalWordSyncButton = document.getElementById('triggerLocalWordSync');
            const localWordPathSpan = document.getElementById('localWordPath');
            const localWordLastSyncSpan = document.getElementById('localWordLastSync');
            const localWordSyncStatusSpan = document.getElementById('localWordSyncStatus');
            const localWordDocCountSpan = document.getElementById('localWordDocCount');

            // New Elements for Word Document Management
            const wordFileUploadInput = document.getElementById('wordFileUpload');
            const uploadWordFileButton = document.getElementById('uploadWordFileButton');
            const wordFilesTableBody = document.getElementById('wordFilesTableBody');
            const wordFileUploadStatusDiv = document.getElementById('word-file-upload-status');
            const wordFileListStatusDiv = document.getElementById('word-file-list-status');
            const WORD_DOCS_UPLOAD_DIR_DISPLAY = "knowledge_docs/word_documents"; // For display purposes

            // New Elements for ZIP Upload
            const zipFileUploadInput = document.getElementById('zipFileUpload');
            const extractFolderNameInput = document.getElementById('extractFolderName');
            const uploadZipFileButton = document.getElementById('uploadZipFileButton');
            const zipFileUploadStatusDiv = document.getElementById('zip-file-upload-status');

            let currentWordFiles = []; // To store the list of current files for checking duplicates

            async function loadKnowledgeBaseSummaryStatus() {
                if (kbSummaryStatusDiv) {
                    kbSummaryStatusDiv.innerHTML = '<p>æ­£åœ¨æ›´æ–°çŸ¥è­˜åº«ç‹€æ…‹æ‘˜è¦...</p>';
                }
                if (websiteSyncStatusSpan) { 
                    websiteSyncStatusSpan.textContent = 'è¼‰å…¥ä¸­...';
                    websiteSyncStatusSpan.style.color = 'grey';
                }
                if (localWordSyncStatusSpan) { // Add for Word docs card
                    localWordSyncStatusSpan.textContent = 'è¼‰å…¥ä¸­...';
                    localWordSyncStatusSpan.style.color = 'grey';
                }
                // Add similar for other cards (MySQL) when they become dynamic

                try {
                    const response = await fetch(`${apiBaseUrl}/knowledgebase/status`);
                    const data = await response.json();

                    // Update Overall Summary Status
                    if (kbSummaryStatusDiv) {
                        if (response.ok && data.overall_status) {
                            const overall = data.overall_status;
                            let summaryHtml = `<h4>çŸ¥è­˜åº«ç‹€æ…‹æ‘˜è¦</h4>
                                <p><strong>æ•´é«”ç‹€æ…‹è¨Šæ¯ï¼š</strong> ${overall.message || 'N/A'}</p>
                                <p><strong>ä¸Šæ¬¡å®Œæ•´é‡å»ºæ™‚é–“ï¼š</strong> ${overall.last_full_rebuild_timestamp ? new Date(overall.last_full_rebuild_timestamp).toLocaleString() : 'å°šæœªåŸ·è¡Œ'}</p>
                                <p><strong>ä»»ä½•ä¾†æºä¸Šæ¬¡åŒæ­¥æ™‚é–“ï¼š</strong> ${overall.last_any_sync_timestamp ? new Date(overall.last_any_sync_timestamp).toLocaleString() : 'å°šæœªåŸ·è¡Œ'}</p>
                                <p><strong>ç´¢å¼•ä¸­ç¸½å‘é‡æ•¸ï¼š</strong> ${overall.total_indexed_vectors !== null ? overall.total_indexed_vectors : 'N/A'}</p>`;
                            if (data.status && data.status !== 'success_loaded') { 
                                summaryHtml += `<p style="color:red;"><strong>ç³»çµ±æç¤ºï¼š</strong> ${data.message} ${data.error_message ? '(' + data.error_message + ')' : ''}</p>`;
                            }
                            kbSummaryStatusDiv.innerHTML = summaryHtml;
                        } else {
                            kbSummaryStatusDiv.innerHTML = `<h4>çŸ¥è­˜åº«ç‹€æ…‹æ‘˜è¦</h4><p>${data.message || 'ç„¡æ³•è¼‰å…¥çŸ¥è­˜åº«æ•´é«”ç‹€æ…‹ã€‚'}</p>`;
                            if(data.error_message) kbSummaryStatusDiv.innerHTML += `<p style="color:red;">éŒ¯èª¤: ${data.error_message}</p>`;
                        }
                    }

                    // Update Website Source Card
                    if (data.sources && data.sources.website) {
                        const websiteData = data.sources.website;
                        if (websiteLastSyncSpan) websiteLastSyncSpan.textContent = websiteData.last_sync_timestamp ? new Date(websiteData.last_sync_timestamp).toLocaleString() : 'å°šæœªåŒæ­¥';
                        if (websiteSyncStatusSpan) {
                            websiteSyncStatusSpan.textContent = `${websiteData.status || 'N/A'} - ${websiteData.message || ''}`;
                            if (websiteData.status === 'success') websiteSyncStatusSpan.style.color = 'green';
                            else if (websiteData.status && websiteData.status.includes('error')) websiteSyncStatusSpan.style.color = 'red';
                            else if (websiteData.status === 'pending' || websiteData.status === 'pending_rebuild') websiteSyncStatusSpan.style.color = 'orange';
                            else websiteSyncStatusSpan.style.color = 'grey'; 
                        }
                        if (websiteArticleCountSpan) {
                            const itemCount = websiteData.embedded_items;
                            websiteArticleCountSpan.textContent = `${itemCount !== null && itemCount !== undefined ? itemCount : '0'} ç¯‡`; 
                        }
                        if (websiteUrlSpan) { 
                            websiteUrlSpan.textContent = websiteData.target_config_url || '(æœªé…ç½®æˆ–æœªçŸ¥)';
                        }
                    } else if (websiteSyncStatusSpan) {
                        websiteSyncStatusSpan.textContent = 'ç¶²ç«™ä¾†æºç‹€æ…‹è³‡è¨Šä¸å¯ç”¨ã€‚';
                        websiteSyncStatusSpan.style.color = 'grey';
                    }

                    // Update Word Documents Source Card (New)
                    if (data.sources && data.sources.word_documents) {
                        const wordData = data.sources.word_documents;
                        if (localWordPathSpan) localWordPathSpan.textContent = wordData.target_config_url || '(æœªé…ç½®æˆ–æœªçŸ¥)';
                        if (localWordLastSyncSpan) localWordLastSyncSpan.textContent = wordData.last_sync_timestamp ? new Date(wordData.last_sync_timestamp).toLocaleString() : 'å°šæœªåŒæ­¥';
                        if (localWordSyncStatusSpan) {
                            localWordSyncStatusSpan.textContent = `${wordData.status || 'N/A'} - ${wordData.message || ''}`;
                            if (wordData.status === 'success') localWordSyncStatusSpan.style.color = 'green';
                            else if (wordData.status && wordData.status.includes('error')) localWordSyncStatusSpan.style.color = 'red';
                            else if (wordData.status === 'pending' || wordData.status === 'pending_rebuild') localWordSyncStatusSpan.style.color = 'orange';
                            else localWordSyncStatusSpan.style.color = 'grey';
                        }
                        if (localWordDocCountSpan) {
                            const itemCount = wordData.embedded_items;
                            // å‡è¨­ embedded_items åæ˜ äº†æ­¤ä¾†æºçš„è¨ˆæ•¸ï¼Œå¾Œç«¯æ‡‰ç¢ºä¿å¡«å……æ­¤å€¼
                            localWordDocCountSpan.textContent = `${itemCount !== null && itemCount !== undefined ? itemCount : '0'} ä»½`; 
                        }
                    } else if (localWordSyncStatusSpan) {
                        localWordSyncStatusSpan.textContent = 'Word æ–‡ä»¶ä¾†æºç‹€æ…‹è³‡è¨Šä¸å¯ç”¨ã€‚';
                        localWordSyncStatusSpan.style.color = 'grey';
                    }

                } catch (error) {
                    console.error('è¼‰å…¥çŸ¥è­˜åº«ç‹€æ…‹ API éŒ¯èª¤:', error);
                    if (kbSummaryStatusDiv) kbSummaryStatusDiv.innerHTML = '<h4>çŸ¥è­˜åº«ç‹€æ…‹æ‘˜è¦</h4><p style="color:red;">ç„¡æ³•é€£æ¥åˆ°ä¼ºæœå™¨æˆ–è¼‰å…¥æ•´é«”ç‹€æ…‹æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚</p>';
                    if (websiteSyncStatusSpan) {
                         websiteSyncStatusSpan.textContent = 'ç„¡æ³•è¼‰å…¥ç‹€æ…‹';
                         websiteSyncStatusSpan.style.color = 'red';
                    }
                    if (localWordSyncStatusSpan) { // Also update for Word docs card on error
                        localWordSyncStatusSpan.textContent = 'ç„¡æ³•è¼‰å…¥ç‹€æ…‹';
                        localWordSyncStatusSpan.style.color = 'red';
                    }
                }
            }

            if (rebuildKbButton) {
                rebuildKbButton.addEventListener('click', async () => {
                    if (!confirm('æ‚¨ç¢ºå®šè¦ç«‹å³é‡å»ºæ•´å€‹çŸ¥è­˜åº«å—ï¼Ÿæ­¤æ“ä½œå¯èƒ½è€—æ™‚è¼ƒé•·ã€‚')) {
                        return;
                    }

                    rebuildStatusDiv.textContent = 'æ­£åœ¨å‚³é€é‡å»ºçŸ¥è­˜åº«è«‹æ±‚ï¼Œè«‹ç¨å€™...';
                    rebuildStatusDiv.className = 'status-message info'; // Use a general info class
                    rebuildStatusDiv.style.display = 'block';
                    rebuildKbButton.disabled = true;

                    try {
                        const response = await fetch(`${apiBaseUrl}/knowledgebase/rebuild`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                                // No body needed for this POST request as per current backend
                            }
                        });

                        const result = await response.json();

                        if (response.ok) {
                            rebuildStatusDiv.textContent = `çŸ¥è­˜åº«é‡å»ºæˆåŠŸï¼š ${result.message}`;
                            rebuildStatusDiv.className = 'status-message success';
                            loadKnowledgeBaseSummaryStatus(); // Reload summary after successful rebuild
                        } else {
                            rebuildStatusDiv.textContent = `çŸ¥è­˜åº«é‡å»ºå¤±æ•—ï¼š ${result.detail || result.message || 'æœªçŸ¥éŒ¯èª¤'}`;
                            rebuildStatusDiv.className = 'status-message error';
                        }
                    } catch (error) {
                        console.error('é‡å»ºçŸ¥è­˜åº« API å‘¼å«éŒ¯èª¤:', error);
                        rebuildStatusDiv.textContent = `é‡å»ºçŸ¥è­˜åº«æ™‚ç™¼ç”Ÿå®¢æˆ¶ç«¯éŒ¯èª¤ï¼š ${error.message}`;
                        rebuildStatusDiv.className = 'status-message error';
                    } finally {
                        rebuildKbButton.disabled = false;
                        // Optional: hide status message after some time
                        // setTimeout(() => { rebuildStatusDiv.style.display = 'none'; }, 10000);
                    }
                });
            }

            // Event listener for Website Sync Button
            if (triggerWebsiteSyncButton) {
                triggerWebsiteSyncButton.addEventListener('click', async () => {
                    if (!confirm('æ‚¨ç¢ºå®šè¦ç«‹å³åŒæ­¥å®˜ç¶²å…§å®¹å—ï¼Ÿ')) {
                        return;
                    }
                    if(rebuildStatusDiv) {
                        rebuildStatusDiv.textContent = 'æ­£åœ¨å‚³é€åŒæ­¥å®˜ç¶²å…§å®¹è«‹æ±‚ï¼Œè«‹ç¨å€™...';
                        rebuildStatusDiv.className = 'status-message info';
                        rebuildStatusDiv.style.display = 'block';
                    }
                    triggerWebsiteSyncButton.disabled = true;
                    await processSyncRequest('website', triggerWebsiteSyncButton);
                });
            }

            // Event listener for Local Word Sync Button (New)
            if (triggerLocalWordSyncButton) {
                triggerLocalWordSyncButton.addEventListener('click', async () => {
                    if (!confirm('æ‚¨ç¢ºå®šè¦ç«‹å³åŒæ­¥æœ¬åœ° Word æ–‡ä»¶å…§å®¹å—ï¼Ÿ')) {
                        return;
                    }
                    if(rebuildStatusDiv) { // Reusing global status div for simplicity
                        rebuildStatusDiv.textContent = 'æ­£åœ¨å‚³é€åŒæ­¥æœ¬åœ° Word æ–‡ä»¶è«‹æ±‚ï¼Œè«‹ç¨å€™...';
                        rebuildStatusDiv.className = 'status-message info';
                        rebuildStatusDiv.style.display = 'block';
                    }
                    triggerLocalWordSyncButton.disabled = true;
                    await processSyncRequest('word_documents', triggerLocalWordSyncButton);
                });
            }

            // Generic function to handle sync requests for different sources
            async function processSyncRequest(sourceName, buttonElement) {
                try {
                    const response = await fetch(`${apiBaseUrl}/sync/${sourceName}`, { method: 'POST' });
                    const result = await response.json();

                    if (response.ok) {
                        if(rebuildStatusDiv) rebuildStatusDiv.textContent = `è³‡æ–™ä¾†æº '${sourceName}' åŒæ­¥æˆåŠŸï¼š${result.message}`;
                        if(rebuildStatusDiv) rebuildStatusDiv.className = 'status-message success';
                    } else {
                        if(rebuildStatusDiv) rebuildStatusDiv.textContent = `è³‡æ–™ä¾†æº '${sourceName}' åŒæ­¥å¤±æ•—ï¼š${result.detail || result.message || 'æœªçŸ¥éŒ¯èª¤'}`;
                        if(rebuildStatusDiv) rebuildStatusDiv.className = 'status-message error';
                    }
                } catch (error) {
                    console.error(`åŒæ­¥è³‡æ–™ä¾†æº '${sourceName}' API å‘¼å«éŒ¯èª¤:`, error);
                    if(rebuildStatusDiv) rebuildStatusDiv.textContent = `åŒæ­¥è³‡æ–™ä¾†æº '${sourceName}' æ™‚ç™¼ç”Ÿå®¢æˆ¶ç«¯éŒ¯èª¤ï¼š ${error.message}`;
                    if(rebuildStatusDiv) rebuildStatusDiv.className = 'status-message error';
                } finally {
                    if (buttonElement) buttonElement.disabled = false;
                    loadKnowledgeBaseSummaryStatus(); // Refresh all statuses
                    loadSyncLog(); // Reload sync log
                    if(rebuildStatusDiv) setTimeout(() => { rebuildStatusDiv.style.display = 'none'; }, 7000);
                }
            }

            // Placeholder for other sync functions if any
            // e.g., loadSyncStatus, handleWordFileSync, handleDbSync etc.
            function loadSyncStatus() {
                // This function could fetch and display current sync status for different data sources
                console.log("loadSyncStatus called - to be implemented for other source cards initially");

                // Load knowledge base summary on initial page load
                loadKnowledgeBaseSummaryStatus();
                loadSyncLog(); // Call to load sync log as well

                // Example: Populate sitemap status (dummy data)
                const sitemapStatus = document.getElementById('sitemap-status');
                if (sitemapStatus) {
                    sitemapStatus.textContent = "ä¸Šæ¬¡æª¢æŸ¥æ™‚é–“ï¼š2024-07-30 10:00 - ç™¼ç¾ 150 å€‹æœ‰æ•ˆé é¢ã€‚";
                }
                 // Example: Populate DB status (dummy data)
                const dbSyncStatus = document.getElementById('db-sync-status');
                if (dbSyncStatus) {
                    dbSyncStatus.textContent = "ä¸Šæ¬¡åŒæ­¥æ™‚é–“ï¼š2024-07-30 11:00 - åŒæ­¥ 50 ç­†æ–°ç—…æ­·ã€‚";
                }
            }

            // Initial load of sync statuses
            loadSyncStatus();

            async function loadSyncLog() {
                const syncLogTableBody = document.getElementById("syncLogTableBody");
                if (!syncLogTableBody) {
                    console.error("Sync log table body (#syncLogTableBody) not found!");
                    return;
                }

                try {
                    const response = await fetch(`${apiBaseUrl}/knowledgebase/sync-log`);
                    if (!response.ok) {
                        console.error("Failed to load sync log:", response.status, await response.text());
                        syncLogTableBody.innerHTML = '<tr><td colspan="4" style="color:red;">ç„¡æ³•è¼‰å…¥åŒæ­¥æ—¥èªŒã€‚</td></tr>';
                        return;
                    }
                    const data = await response.json();
                    const logs = data.logs;

                    syncLogTableBody.innerHTML = ''; // Clear existing mock data or old logs

                    if (logs && logs.length > 0) {
                        logs.forEach(log => {
                            const row = syncLogTableBody.insertRow();
                            const cellTimestamp = row.insertCell();
                            const cellSource = row.insertCell();
                            const cellStatus = row.insertCell();
                            const cellMessage = row.insertCell();

                            cellTimestamp.textContent = new Date(log.timestamp).toLocaleString();
                            cellSource.textContent = `${log.source_name} (${log.operation_type})`;
                            cellStatus.textContent = log.status;
                            cellMessage.textContent = log.message;

                            // Optional: Add styling based on status
                            if (log.status.toLowerCase().includes('error')) {
                                cellStatus.style.color = 'red';
                            } else if (log.status.toLowerCase().includes('success')) {
                                cellStatus.style.color = 'green';
                            } else if (log.status.toLowerCase().includes('started') || log.status.toLowerCase().includes('pending')) {
                                cellStatus.style.color = 'orange';
                            }
                        });
                    } else {
                        syncLogTableBody.innerHTML = '<tr><td colspan="4">ç›®å‰æ²’æœ‰åŒæ­¥æ—¥èªŒè¨˜éŒ„ã€‚</td></tr>';
                    }
                } catch (error) {
                    console.error('è¼‰å…¥åŒæ­¥æ—¥èªŒ API éŒ¯èª¤:', error);
                    syncLogTableBody.innerHTML = '<tr><td colspan="4" style="color:red;">è¼‰å…¥åŒæ­¥æ—¥èªŒæ™‚ç™¼ç”Ÿå®¢æˆ¶ç«¯éŒ¯èª¤ã€‚</td></tr>';
                }
            }

            // --- Word Document Management Functions ---
            function showFileUploadStatus(message, isError = false) {
                wordFileUploadStatusDiv.textContent = message;
                wordFileUploadStatusDiv.className = 'status-message';
                if (isError) wordFileUploadStatusDiv.classList.add('error');
                else wordFileUploadStatusDiv.classList.add('success');
                wordFileUploadStatusDiv.style.display = 'block';
                setTimeout(() => { wordFileUploadStatusDiv.style.display = 'none'; }, 5000);
            }

            function showFileListStatus(message, isError = false) {
                wordFileListStatusDiv.textContent = message;
                wordFileListStatusDiv.className = 'status-message';
                if (isError) wordFileListStatusDiv.classList.add('error');
                else wordFileListStatusDiv.classList.add('success');
                wordFileListStatusDiv.style.display = 'block';
                setTimeout(() => { wordFileListStatusDiv.style.display = 'none'; }, 3000);
            }

            async function loadWordFiles() {
                showFileListStatus('æ­£åœ¨è¼‰å…¥ Word æ–‡ä»¶åˆ—è¡¨...');
                try {
                    const response = await fetch(`${apiBaseUrl}/knowledgebase/word-documents`);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                        throw new Error(`è¼‰å…¥æª”æ¡ˆåˆ—è¡¨å¤±æ•—: ${response.status} ${errorData.detail}`);
                    }
                    const fileTree = await response.json();
                    renderWordFilesTree(fileTree, wordFilesTableBody, 0); // Initial call with level 0
                    
                    if (fileTree.length === 0) {
                        showFileListStatus('çŸ¥è­˜åº«ä¸­ç›®å‰æ²’æœ‰ Word æ–‡ä»¶æˆ–è³‡æ–™å¤¾ã€‚');
                        wordFilesTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">çŸ¥è­˜åº«ä¸­ç›®å‰æ²’æœ‰ Word æ–‡ä»¶æˆ–è³‡æ–™å¤¾ã€‚</td></tr>';
                    } else {
                        showFileListStatus('Word æ–‡ä»¶åˆ—è¡¨å·²è¼‰å…¥ã€‚');
                    }
                } catch (error) {
                    console.error('è¼‰å…¥ Word æª”æ¡ˆåˆ—è¡¨éŒ¯èª¤:', error);
                    showFileListStatus(error.message, true);
                    wordFilesTableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; color:red;">ç„¡æ³•è¼‰å…¥æ–‡ä»¶åˆ—è¡¨: ${error.message}</td></tr>`;
                }
            }

            function renderWordFilesTree(items, parentElement, level) {
                if (level === 0) { // Clear only on the first call for the root
                    parentElement.innerHTML = ''; 
                }

                items.forEach(item => {
                    const row = parentElement.insertRow();
                    const nameCell = row.insertCell();
                    nameCell.style.paddingLeft = `${level * 20}px`; // Indentation for tree view

                    if (item.type === 'folder') {
                        nameCell.innerHTML = `<strong>ğŸ“ ${item.name}</strong> (è³‡æ–™å¤¾)`;
                        row.insertCell().textContent = '-'; // Size for folder
                        row.insertCell().textContent = '-'; // Modified date for folder
                        row.insertCell(); // Empty cell for actions on folder (can add e.g. expand/collapse later)
                        
                        if (item.children && item.children.length > 0) {
                            // Recursively render children. For a table, this means adding more rows under this one.
                            // A true tree table might require more complex row spanning or a different HTML structure (e.g., nested ULs).
                            // For simplicity here, we'll just list them sequentially with indentation.
                            renderWordFilesTree(item.children, parentElement, level + 1);
                        }
                    } else if (item.type === 'file') {
                        nameCell.textContent = `ğŸ“„ ${item.name}`;
                        row.insertCell().textContent = `${(item.size / 1024).toFixed(2)} KB`;
                        row.insertCell().textContent = new Date(item.modified_at).toLocaleString();
                        
                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'åˆªé™¤';
                        deleteButton.classList.add('button', 'button-danger', 'button-small');
                        // Pass the full relative path for deletion
                        deleteButton.onclick = () => handleDeleteWordFile(item.path); 
                        row.insertCell().appendChild(deleteButton);
                    }
                });
                 // If it's the initial call and no items were rendered (empty root), display a message.
                if (level === 0 && parentElement.rows.length === 0 && items.length > 0) {
                    // This case should ideally be handled by the check in loadWordFiles before calling render
                } else if (level === 0 && items.length === 0) {
                     // This is handled in loadWordFiles now.
                     // parentElement.innerHTML = '<tr><td colspan="4" style="text-align:center;">çŸ¥è­˜åº«ä¸­ç›®å‰æ²’æœ‰ Word æ–‡ä»¶æˆ–è³‡æ–™å¤¾ã€‚</td></tr>';
                }
            }

            async function handleDeleteWordFile(filepath) { // filepath is now relative path
                if (!confirm(`æ‚¨ç¢ºå®šè¦åˆªé™¤æª”æ¡ˆ '${filepath}' å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚`)) {
                    return;
                }
                showFileUploadStatus(`æ­£åœ¨åˆªé™¤æª”æ¡ˆ '${filepath}'`);
                try {
                    // Encode the filepath component to handle special characters like '/'
                    const encodedFilepath = encodeURIComponent(filepath);
                    const response = await fetch(`${apiBaseUrl}/knowledgebase/word-documents/${encodedFilepath}`, {
                        method: 'DELETE'
                    });
                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.detail || `åˆªé™¤å¤±æ•—: ${response.status}`);
                    }
                    showFileUploadStatus(result.message || `æª”æ¡ˆ '${filepath}' å·²æˆåŠŸåˆªé™¤`);
                    loadWordFiles(); // Refresh the list
                } catch (error) {
                    console.error('åˆªé™¤ Word æª”æ¡ˆéŒ¯èª¤:', error);
                    showFileUploadStatus(error.message, true);
                }
            }

            if (uploadWordFileButton) {
                uploadWordFileButton.addEventListener('click', async () => {
                    const fileInput = wordFileUploadInput;
                    if (!fileInput.files || fileInput.files.length === 0) {
                        showFileUploadStatus('è«‹å…ˆé¸æ“‡ä¸€å€‹ .docx æª”æ¡ˆã€‚', true);
                        return;
                    }
                    const file = fileInput.files[0];
                    if (!file.name.endsWith('.docx')) {
                        showFileUploadStatus('æª”æ¡ˆé¡å‹éŒ¯èª¤ï¼Œåƒ…æ”¯æ´ .docx æ ¼å¼ã€‚', true);
                        return;
                    }

                    let overwrite = false;
                    if (currentWordFiles.includes(file.name)) {
                        if (!confirm(`æª”æ¡ˆ '${file.name}' å·²å­˜åœ¨æ–¼ '${WORD_DOCS_UPLOAD_DIR_DISPLAY}' ä¸­ã€‚æ‚¨æƒ³è¦è¦†è“‹å®ƒå—ï¼Ÿ`)) {
                            showFileUploadStatus('ä¸Šå‚³å·²å–æ¶ˆã€‚');
                            fileInput.value = ''; // Reset file input
                            return;
                        }
                        overwrite = true;
                    }

                    const formData = new FormData();
                    formData.append('file', file);

                    showFileUploadStatus(`æ­£åœ¨ä¸Šå‚³æª”æ¡ˆ '${file.name}' ...`);
                    try {
                        const response = await fetch(`${apiBaseUrl}/knowledgebase/word-documents/upload?overwrite=${overwrite}`, {
                            method: 'POST',
                            body: formData
                            // 'Content-Type': 'multipart/form-data' is set automatically by browser for FormData
                        });
                        const result = await response.json();
                        if (!response.ok) {
                            throw new Error(result.detail || `ä¸Šå‚³å¤±æ•—: ${response.status}`);
                        }
                        showFileUploadStatus(result.message || `æª”æ¡ˆ '${file.name}' å·²æˆåŠŸä¸Šå‚³`);
                        fileInput.value = ''; // Reset file input
                        loadWordFiles(); // Refresh the list
                    } catch (error) {
                        console.error('ä¸Šå‚³ Word æª”æ¡ˆéŒ¯èª¤:', error);
                        showFileUploadStatus(error.message, true);
                    }
                });
            }

            // --- ZIP Upload Functionality ---
            if (uploadZipFileButton) {
                uploadZipFileButton.addEventListener('click', async () => {
                    if (!zipFileUploadInput.files || zipFileUploadInput.files.length === 0) {
                        showZipUploadStatus('è«‹å…ˆé¸æ“‡ä¸€å€‹ .zip æª”æ¡ˆã€‚', true);
                        return;
                    }
                    const file = zipFileUploadInput.files[0];
                    if (!file.name.endsWith('.zip')) {
                        showZipUploadStatus('æª”æ¡ˆé¡å‹éŒ¯èª¤ï¼Œåƒ…æ”¯æ´ .zip æ ¼å¼ã€‚', true);
                        return;
                    }

                    const extractToFolder = extractFolderNameInput.value.trim();
                    const formData = new FormData();
                    formData.append('file', file);
                    if (extractToFolder) {
                        formData.append('extract_to_folder_name', extractToFolder);
                    }

                    showZipUploadStatus(`æ­£åœ¨ä¸Šå‚³ä¸¦è§£å£“ç¸® ZIP æª”æ¡ˆ '${file.name}' ...`);
                    try {
                        const response = await fetch(`${apiBaseUrl}/knowledgebase/upload-zip`, {
                            method: 'POST',
                            body: formData
                        });
                        const result = await response.json();
                        if (!response.ok) {
                            throw new Error(result.detail || `ZIP ä¸Šå‚³æˆ–è§£å£“ç¸®å¤±æ•—: ${response.status}`);
                        }
                        showZipUploadStatus(`${result.message} (å…± ${result.extracted_files_count} å€‹æª”æ¡ˆè¢«è§£å£“ç¸®)`);
                        zipFileUploadInput.value = ''; // Reset file input
                        extractFolderNameInput.value = ''; // Reset folder name input
                        loadWordFiles(); // Refresh the entire file tree
                    } catch (error) {
                        console.error('ä¸Šå‚³æˆ–è§£å£“ç¸® ZIP æª”æ¡ˆéŒ¯èª¤:', error);
                        showZipUploadStatus(error.message, true);
                    }
                });
            }

            function showZipUploadStatus(message, isError = false) {
                zipFileUploadStatusDiv.textContent = message;
                zipFileUploadStatusDiv.className = 'status-message';
                if (isError) zipFileUploadStatusDiv.classList.add('error');
                else zipFileUploadStatusDiv.classList.add('success');
                zipFileUploadStatusDiv.style.display = 'block';
                setTimeout(() => { zipFileUploadStatusDiv.style.display = 'none'; }, 7000);
            }

            // --- End Word Document Management Functions ---

            // Initial loads
            loadKnowledgeBaseSummaryStatus();
            loadSyncLog(); // Assuming loadSyncLog() is defined elsewhere or will be defined
            loadWordFiles(); // Load Word files on page load
        });
    </script>
</body>
</html> 